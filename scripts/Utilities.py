""" Convenience functions to support the code generator. """

__author__ = 'Alessandro Pasetti, P&P software GmbH'

import sys
import os
import argparse
import shutil
import csv
import pdb
import json
import operator
import re
import copy
import zipfile
import datetime;

""" Maximum length of a line in doxygen comment """
MAX_LINE_LENGTH = 80

#===============================================================================
def writeDoxy(lines):
    """ Write a list of strings as a doxygen comment to a string and return the string.
        Empty items in the list of strings are ignored.
        Strings which are longer than MAX_LINE_LENGTH are split to fit within MAX_LINE_LENGTH.    
    """
    f = ''
    newLines = []
    for line in lines:
        if line == '':
            continue
        if len(line)<=MAX_LINE_LENGTH:
            newLines.append(line)
        else:
            words = line.split()
            newLine = ''
            length = 0
            for word in words:
                length += len(word)+1
                newLine += word + ' '
                if (length>MAX_LINE_LENGTH):
                    newLines.append(newLine)
                    newLine = ''
                    length =0
            if length>0:
                newLines.append(newLine)
       
    if len(newLines) == 1:
        f += '/** ' + newLines[0] + ' */'+'\n'
    else:
        f = f + '/**\n'
        for s in newLines:
            f = f + ' * ' + s + '\n'
        f = f + ' */\n'
    return f

#===============================================================================
def formatAsPartOfComment(text):
    """The function takes as an argument a string representing part of comment 
    to go into a C-style function comment. The string may be very long and may 
    contain carriage returns {'\n'). 
    The output of the function should be another string which contains the same
    text as in the argument string but formatted as follows:
    (a) It should consist of a sequence of lines separated by carriage returns
    (b) A line should not be longer than 80 characters
    (c) Words should not be split across lines
    (d) Each line should start with the following characters: ' *'
    """
    words = text.split()
    lines = []
    line = ' *'
    line_length = 2  # account for the initial ' *'
    
    for word in words:
        if line_length + len(word) + 1 > MAX_LINE_LENGTH:
            lines.append(line)
            line = ' * ' + word
            line_length = 3 + len(word)
        else:
            line += ' ' + word
            line_length += len(word) + 1
    
    lines.append(line)
    return '\n'.join(lines)
    
#===============================================================================
# Create a body file with the given name and the given content.
def createBodyFile(dirName, modelName, content, shortDesc):
    name = dirName + '/' + fileName + '.c'
    ct = str(datetime.datetime.now())
    with open(name, 'w') as fd:
        fd.write('/**                                          \n')
        fd.write(' * @ingroup gen_cfw                          \n')
        fd.write(' *                                           \n')
        fd.write(formatAsPartOfComment(shortDesc) + '  \n')
        fd.write(' *                                           \n')
        fd.write(' * @note This file was generated on  ' + ct + '\n')
        fd.write(' * @author Automatically generated by CORDET Editor Code Generator\n')
        fd.write(' * @copyright P&P Software GmbH\n')
        fd.write(' */                                          \n')
        fd.write('\n')
        fd.write(content)

#===============================================================================
# Create a header file for a procedure or state machine model.
def createHeaderFile(dirName, modelName, content, modelDesc):
    name = dirName + '/' + modelName + '.h'
    ct = str(datetime.datetime.now())
    ifdefName = modelName.replace('_','').upper()
    with open(name, 'w') as fd:
        fd.write('/**                                          \n')
        fd.write(formatAsPartOfComment(modelDesc) + '  \n')
        fd.write(' *                                           \n')
        fd.write(' * @note This file was generated on  ' + ct + '\n')
        fd.write(' * @author Automatically generated by FW Profile Code Generator\n')
        fd.write(' * @copyright P&P Software GmbH\n')
        fd.write(' */                                          \n')
        fd.write('#ifndef ' + ifdefName + '_H_\n')
        fd.write('#define ' + ifdefName + '_H_\n')
        fd.write('\n')
        fd.write(content)
        fd.write('#endif /* ' + ifdefName + '_H_ */\n')
    
#===============================================================================
# Create a string representing the #define statement for constant (inclusive of 
# its doxygen comment)
def createVarDef(specItem):
    assert specItem['cat'] == 'DataItem'
    s = ''
    if specItem['remarks'] != '':
        writeDoxy(s, [specItem['desc'], specItem['remarks']])
    else:
        writeDoxy(s, [specItem['desc']])
    s = s + '#define ' + specItem['name'] + '(' +  specItem['value']  + ')'
    return s 
    
        
